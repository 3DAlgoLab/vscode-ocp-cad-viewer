<!DOCTYPE html>
<!--

Copyright 2025 Bernhard Walter

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-->

<!-- {var} are template variables and will be resolved in display.js-->
<html>

<head>
  <meta charset="utf-8" />
  <title>OCP CAD Viewer</title>
  <link rel="stylesheet" href="{{ styleSrc }}" />
  {{ standalone_scripts|safe }}
  <script type="module">
    // Import core CAD viewer components from the main script
    import { Viewer, Display, Timer } from "{{ scriptSrc }}";
    { { standalone_imports | safe } } // prettier-ignore

    // Global variables for viewer state management
    var viewer = null;           // Main Viewer instance for 3D rendering
    var display = null;          // Display instance for UI management
    var _shapes = null;           // Current 3D shapes data
    var _states = null;           // Current viewer states
    var _config = null;           // Current configuration settings
    var _zoom = null;             // Current camera zoom level
    var _position = null;         // Current camera position
    var _camera_distance = null;  // Current camera distance from target
    var _quaternion = null;       // Current camera rotation quaternion
    var _target = null;           // Current camera target point
    var _clipping = {             // Current clipping plane settings
      sliders: [],              // Clipping plane slider values
      normals: [],              // Clipping plane normal vectors
      planeHelpers: null,       // Clipping plane helper objects
      objectColors: null,       // Object colors for clipping
      intersection: null        // Clipping intersection mode
    };
    var oldStates = null;         // Previous tree view states for change detection
    var viewerOptions = {};       // Current viewer configuration options
    var last_bb_radius = null;    // Last calculated bounding box radius

    // Minimum width constraint for the CAD viewer display
    const minWidth = 450;
    { { standalone_comms | safe } } // prettier-ignore

    // Message object for communicating state changes back to VSCode extension
    var message = {};

    // Default configuration options for the Display component
    const displayDefaultOptions = {
      cadWidth: 730,                                    // Width of the CAD viewport in pixels
      height: 525,                                       // Height of the CAD viewport in pixels
      treeWidth: JSON.parse("{{ treeWidth }}"),         // Width of the object tree panel
      glass: JSON.parse("{{ glass|tojson }}"),          // Glass mode (minimal UI) flag
      theme: "{{ theme }}",                              // Visual theme (light/dark/browser)
      tools: JSON.parse("{{ tools|tojson }}"),          // Whether to show toolbar tools
      pinning: false,                                    // Whether UI elements can be pinned
      keymap: {                                          // Keyboard modifier key mappings
        shift: "shiftKey",                            // Shift key modifier
        ctrl: "ctrlKey",                              // Ctrl key modifier
        meta: "metaKey",                              // Meta/Cmd key modifier
        alt: "altKey"                                 // Alt key modifier
      },
      newTreeBehavior: true,                            // Enable new tree view behavior
      measurementDebug: false,                           // Enable measurement tool debugging
      measureTools: true,                               // Enable measurement tools
      selectTool: true,                                 // Enable selection tool
      explodeTool: true,                                // Enable explode tool
      zscaleTool: false                                 // Enable Z-axis scaling tool
    };

    // Default configuration options for the Viewer component
    const viewerDefaultOptions = {
      timeit: false,                                     // Enable performance timing
      tools: JSON.parse("{{ tools|tojson }}"),          // Whether to show toolbar tools
      glass: JSON.parse("{{ glass|tojson }}"),          // Glass mode (minimal UI) flag
      up: "{{ up }}",                                    // Up vector for camera orientation
      zoom: 1.0,                                         // Default zoom level
      position: null,                                    // Default camera position
      quaternion: null,                                 // Default camera rotation
      target: null,                                      // Default camera target point
      control: "{{ control }}",                          // Camera control type (orbit/trackball)
      centerGrid: false,                                 // Whether to center the grid
      gridFontSize: 12,                                  // Font size for grid labels
      newTreeBehavior: true                              // Enable new tree view behavior
    };

    // Default rendering options for 3D object materials and lighting
    const renderDefaultOptions = {
      ambientIntensity: 1.0,                            // Ambient light intensity
      directIntensity: 1.1,                             // Direct light intensity
      metalness: 0.3,                                   // Material metalness factor (0-1)
      roughness: 0.65,                                  // Material roughness factor (0-1)
      edgeColor: 0x707070,                              // Default edge color (gray)
      defaultOpacity: 0.5,                              // Default object opacity
      normalLen: 0,                                     // Length of normal vectors (0=hidden)
      angularTolerance: 0.2,                            // Angular tolerance for tessellation
      deviation: 0.1,                                    // Deviation tolerance for tessellation
      defaultColor: "#e8b024"                           // Default object color (gold)
    };

    /**
     * Debug logging function that outputs to both console and VSCode extension
     * @param {string} tag - Log category or identifier
     * @param {Object} obj - Object to log (optional)
     */
    function debugLog(tag, obj) {
      console.log(tag, obj);
      let msg = tag + (obj ? " " + JSON.stringify(obj) : "");
      send("log", msg);
    }

    // Hexadecimal character to numeric value mapping for binary data conversion
    const MAP_HEX = {
      0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
      a: 10, b: 11, c: 12, d: 13, e: 14, f: 15,
      A: 10, B: 11, C: 12, D: 13, E: 14, F: 15
    };

    /**
     * Convert hexadecimal string to Uint8Array of bytes
     * @param {string} hexString - Hexadecimal string to convert
     * @returns {Uint8Array} Array of bytes representing the hex data
     */
    function fromHex(hexString) {
      const bytes = new Uint8Array(
        Math.floor((hexString || "").length / 2)
      );
      let i;
      for (i = 0; i < bytes.length; i++) {
        const a = MAP_HEX[hexString[i * 2]];
        const b = MAP_HEX[hexString[i * 2 + 1]];
        if (a === undefined || b === undefined) {
          break;
        }
        bytes[i] = (a << 4) | b;
      }
      return i === bytes.length ? bytes : bytes.slice(0, i);
    }

    /**
     * Convert base64 string to Uint8Array of bytes
     * @param {string} s - Base64 encoded string to convert
     * @returns {Uint8Array} Array of bytes representing the base64 data
     */
    function fromB64(s) {
      let bytes = atob(s);
      let uint = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++)
        uint[i] = bytes[i].charCodeAt(0);
      return uint;
    }

    /**
     * Decode binary mesh data from compressed format (hex/base64) to typed arrays
     * Processes vertex data, normals, triangles, edges, and other mesh attributes
     * @param {Object} data - Data object containing compressed mesh information
     */
    function decode(data) {
      /**
       * Convert compressed buffer data to typed arrays based on data type
       * @param {Object} obj - Object containing buffer data and metadata
       * @returns {TypedArray|Array} Converted typed array or array of converted objects
       */
      function convert(obj) {
        let result;
        if (typeof obj.buffer == "string") {
          let buffer;
          if (obj.codec === "b64") {
            buffer = fromB64(obj.buffer);
          } else {
            buffer = fromHex(obj.buffer);
          }
          if (obj.dtype === "float32") {
            result = new Float32Array(buffer.buffer);
          } else if (obj.dtype === "int32") {
            result = new Uint32Array(buffer.buffer);
          } else if (obj.dtype === "uint32") {
            result = new Uint32Array(buffer.buffer);
          } else {
            debugLog("Error: unknown dtype", obj.dtype);
          }
        } else if (Array.isArray(obj)) {
          result = [];
          for (let arr of obj) {
            result.push(convert(arr));
          }
          return result;
        } else {
          debugLog("Error: unknown buffer type", obj.buffer);
        }
        return result;
      }

      /**
       * Combine multiple Float32Arrays into a single contiguous array
       * @param {Array<Float32Array>} input - Array of Float32Arrays to combine
       * @returns {Float32Array} Combined array
       */
      function combineFloatArrays(input) {
        let totalLength = 0;
        for (let i = 0; i < input.length; i++) {
          totalLength += input[i].length;
        }
        let output = new Float32Array(totalLength);
        let offset = 0;
        for (let i = 0; i < input.length; i++) {
          output.set(input[i], offset);
          offset += input[i].length;
        }
        return output;
      }

      /**
       * Recursively walk through shape data structure and convert all buffer data
       * @param {Object} obj - Shape object to process
       */
      function walk(obj) {
        let type = null;
        for (let attr in obj) {
          if (attr === "parts") {
            for (let i in obj.parts) {
              walk(obj.parts[i]);
            }
          } else if (attr === "type") {
            type = obj.type;
          } else if (attr === "shape") {
            if (type === "shapes") {
              if (obj.shape.ref === undefined) {
                // Convert all mesh attributes for shape objects
                obj.shape.vertices = convert(obj.shape.vertices);
                obj.shape.obj_vertices = convert(obj.shape.obj_vertices);
                obj.shape.normals = convert(obj.shape.normals);
                obj.shape.edge_types = convert(obj.shape.edge_types);
                obj.shape.face_types = convert(obj.shape.face_types);
                obj.shape.triangles = convert(obj.shape.triangles);
                obj.shape.triangles_per_face = convert(obj.shape.triangles_per_face);
                obj.shape.edges = convert(obj.shape.edges);
                obj.shape.segments_per_edge = convert(obj.shape.segments_per_edge);
              } else {
                // Handle shape references to shared instances
                const ind = obj.shape.ref;
                if (ind !== undefined) {
                  obj.shape = instances[ind];
                }
              }
            } else if (type === "edges") {
              // Convert edge-specific attributes
              obj.shape.edges = convert(obj.shape.edges);
              obj.shape.segments_per_edge = convert(obj.shape.segments_per_edge);
              obj.shape.obj_vertices = convert(obj.shape.obj_vertices);
            } else {
              // Convert object vertices for other types
              obj.shape.obj_vertices = convert(obj.shape.obj_vertices);
            }
          }
        }
      }

      // Process all mesh instances and convert their buffer data
      const instances = data.data.instances;

      data.data.instances.forEach((instance) => {
        instance.vertices = convert(instance.vertices);
        instance.obj_vertices = convert(instance.obj_vertices);
        instance.normals = convert(instance.normals);
        instance.edge_types = convert(instance.edge_types);
        instance.face_types = convert(instance.face_types);
        instance.triangles = convert(instance.triangles);
        instance.triangles_per_face = convert(instance.triangles_per_face);
        instance.edges = convert(instance.edges);
        instance.segments_per_edge = convert(instance.segments_per_edge);
      });

      // Process the shape hierarchy
      walk(data.data.shapes);

      // Clear instances array after processing to free memory
      data.data.instances = [];
    }

    /**
     * Create a THREE.Vector3 object from an array or default to origin
     * @param {Array<number>} initArray - Optional array of 3 numbers [x, y, z]
     * @returns {THREE.Vector3} Three.js Vector3 object
     */
    function vector3(initArray) {
      if (viewer) {
        let v = viewer.camera.getCamera().position.clone(); // just get some THREE.Vector3
        if (initArray) {
          v.fromArray(initArray);
        } else {
          v.fromArray([0, 0, 0]);
        }
        return v;
      } else {
      }
    }

    /**
     * Calculate the Euclidean length (magnitude) of a 3D vector
     * @param {Array<number>} v - 3D vector as [x, y, z]
     * @returns {number} Vector length
     */
    function length(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    }

    /**
     * Normalize a 3D vector to unit length
     * @param {Array<number>} v - 3D vector as [x, y, z]
     * @returns {Array<number>} Normalized vector
     */
    function normalize(v) {
      let n = length(v);
      return [v[0] / n, v[1] / n, v[2] / n];
    }

    /**
     * Send a message to the VSCode extension via postMessage
     * @param {string} command - Command type (e.g., "status", "log", "screenshot")
     * @param {Object|string} message - Message payload to send
     */
    function send(command, message) {
      vscode.postMessage({
        command: command,
        text: message
      });
    }

    /**
     * Notification callback function for viewer state changes
     * Called by the Viewer when any property changes (zoom, position, clipping, etc.)
     * Updates global state variables and sends status updates to VSCode extension
     * @param {Object} change - Object containing changed properties with old/new values
     */
    function nc(change) {
      if (_config.debug) {
        debugLog("notify", change);
      }

      // Update camera state variables
      if (change.zoom !== undefined) {
        _zoom = change.zoom.new;
      }
      if (change.position !== undefined) {
        _position = change.position.new;
      }
      if (change.quaternion !== undefined) {
        _quaternion = change.quaternion.new;
      }
      if (change.target !== undefined) {
        _target = change.target.new;
      }

      // Update clipping state variables
      if (change.clip_intersection !== undefined) {
        _clipping.intersection = change.clip_intersection.new;
      }
      if (change.clip_planes !== undefined) {
        _clipping.planeHelpers = change.clip_planes.new;
      }
      if (change.clip_object_colors !== undefined) {
        _clipping.objectColors = change.clip_object_colors.new;
      }
      if (change.clip_slider_0 !== undefined) {
        _clipping.sliders[0] = change.clip_slider_0.new;
      }
      if (change.clip_slider_1 !== undefined) {
        _clipping.sliders[1] = change.clip_slider_1.new;
      }
      if (change.clip_slider_2 !== undefined) {
        _clipping.sliders[2] = change.clip_slider_2.new;
      }
      if (change.clip_normal_0 !== undefined) {
        _clipping.normals[0] = change.clip_normal_0.new;
      }
      if (change.clip_normal_1 !== undefined) {
        _clipping.normals[1] = change.clip_normal_1.new;
      }
      if (change.clip_normal_2 !== undefined) {
        _clipping.normals[2] = change.clip_normal_2.new;
      }

      // Build message object with changed properties
      let changed = false;
      Object.keys(change).forEach((k) => {
        if (
          // (k !== "states") &&
          change[k].new !== undefined
        ) {
          message[k] = change[k].new;
          changed = true;
        }
      });

      // Handle tree view state changes
      if (viewer != null && viewer.treeview != null) {
        // ensure to clone the object
        const states_json = JSON.stringify(
          viewer.treeview.getStates()
        );
        const states = JSON.parse(states_json);
        if (
          oldStates == null ||
          JSON.stringify(oldStates) != states_json
        ) {
          message["states"] = states;
          oldStates = states;
          changed = true;
        }
      }

      // Send status update if any changes occurred
      if (changed) {
        send("status", message);
      }
    }

    /**
     * Calculate normalized CAD viewport width accounting for tree panel and minimum constraints
     * @param {number} width - Total available width
     * @param {boolean} glass - Whether glass mode is enabled
     * @param {boolean} tools - Whether tools are shown
     * @returns {number} Normalized CAD viewport width
     */
    function normalizeWidth(width, glass, tools) {
      const treeWidth =
        glass || !tools
          ? 0
          : preset(
            _config,
            "tree_width",
            displayDefaultOptions.treeWidth
          );
      return Math.max(minWidth - treeWidth, width - treeWidth - 20);
    }

    /**
     * Calculate normalized viewport height accounting for UI chrome
     * @param {number} height - Total available height
     * @returns {number} Normalized viewport height
     */
    function normalizeHeight(height) {
      return height - 65;
    }

    /**
     * Get current window dimensions
     * @returns {Object} Object with width and height properties
     */
    function getSize() {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }

    /**
     * Get configuration value with fallback to default
     * @param {Object} config - Configuration object
     * @param {string} key - Configuration key
     * @param {*} val - Default value if key not found
     * @returns {*} Configuration value or default
     */
    function preset(config, key, val) {
      return config == null || config[key] == null
        ? val
        : config[key];
    }

    /**
     * Build display options object by merging defaults with current configuration
     * @param {string} theme - Optional theme override
     * @returns {Object} Complete display options configuration
     */
    function getDisplayOptions(theme) {
      const size = getSize();
      const glass = preset(
        _config,
        "glass",
        displayDefaultOptions.glass
      );
      theme = theme ? theme : displayDefaultOptions.theme;
      const tools = preset(
        _config,
        "tools",
        displayDefaultOptions.tools
      );
      const treeWidth = preset(
        _config,
        "tree_width",
        displayDefaultOptions.treeWidth
      );
      const keymap = preset(
        _config,
        "modifier_keys",
        displayDefaultOptions.keymap
      );
      const newTreeBehavior = preset(
        _config,
        "new_tree_behavior",
        viewerDefaultOptions.newTreeBehavior
      );
      const cadWidth = normalizeWidth(size.width, glass, tools);
      return {
        glass: glass,
        treeWidth: treeWidth,
        cadWidth: cadWidth,
        height: normalizeHeight(size.height),
        theme: theme,
        tools: tools,
        keymap: keymap,
        newTreeBehavior: newTreeBehavior,
        measureTools: displayDefaultOptions.measureTools,
        selectTool: displayDefaultOptions.selectTool,
        explodeTool: displayDefaultOptions.explodeTool,
        zscaleTool: displayDefaultOptions.zscaleTool,
        measurementDebug: displayDefaultOptions.measurementDebug
      };
    }

    /**
     * Initialize and show the CAD viewer with given shapes and configuration
     * Creates or reuses Display and Viewer instances, handles cleanup of previous viewer
     * @param {Object} shapes - 3D shapes data to display
     * @param {Object} config - Viewer configuration options
     * @returns {Viewer} The created Viewer instance
     */
    function showViewer(shapes, config) {
      debugLog("showViewer called");

      // Clean up existing viewer if present
      if (viewer != null) {
        viewer.hasAnimationLoop = false;
        viewer.continueAnimation = false;
        viewer.dispose();
        viewer = null;
      }

      // Store shapes and configuration globally
      _shapes = shapes;
      _config = config;

      // Get display options based on configuration
      const displayOptions = getDisplayOptions(config.theme);

      // Create Display instance if needed
      if (display == null) {
        const container = document.getElementById("cad_viewer");
        container.innerHTML = "";
        display = new Display(container, displayOptions);
      }

      // Ensure configuration exists
      if (_config == null) {
        debugLog("OCP CAD Viewer: config is null");
        _config = {};
      }

      // Debug logging if enabled
      if (_config.debug) {
        debugLog("_config", _config);
        debugLog("displayOptions", displayOptions);
      }

      // Turn off animation loop of last viewer (redundant check)
      if (viewer != null) {
        viewer.hasAnimationLoop = false;
        viewer.continueAnimation = false;
      }

      // Create new Viewer instance with notification callback
      viewer = new Viewer(display, displayOptions, nc, null);

      // Render shapes if available
      if (_shapes) render();

      // Apply display mode settings
      display.glassMode(displayOptions.glass);
      display.showTools(displayOptions.tools);

      debugLog("showViewer finished");

      return viewer;

      // viewer.trimUI(["axes", "axes0", "grid", "ortho", "more", "help"])
    }

    /**
     * Main rendering function that processes shapes and renders them in the viewer
     * Handles camera positioning, clipping planes, materials, and viewer options
     */
    function render() {
      // Build render options from configuration and defaults
      const renderOptions = {
        ambientIntensity: preset(
          _config,
          "ambient_intensity",
          renderDefaultOptions.ambientIntensity
        ),
        directIntensity: preset(
          _config,
          "direct_intensity",
          renderDefaultOptions.directIntensity
        ),
        metalness: preset(
          _config,
          "metalness",
          renderDefaultOptions.metalness
        ),
        roughness: preset(
          _config,
          "roughness",
          renderDefaultOptions.roughness
        ),
        edgeColor: preset(
          _config,
          "default_edgecolor",
          renderDefaultOptions.defaultEdgecolor
        ),
        defaultOpacity: preset(
          _config,
          "default_opacity",
          renderDefaultOptions.defaultOpacity
        ),
        normalLen: preset(
          _config,
          "normal_len",
          renderDefaultOptions.normalLen
        )
      };

      // Build viewer options from configuration and defaults
      viewerOptions = {
        axes: preset(_config, "axes", viewerDefaultOptions.axes),
        axes0: preset(_config, "axes0", viewerDefaultOptions.axes0),
        blackEdges: preset(
          _config,
          "black_edges",
          viewerDefaultOptions.blackEdges
        ),
        grid: preset(_config, "grid", viewerDefaultOptions.grid),
        collapse: preset(
          _config,
          "collapse",
          viewerDefaultOptions.collapse
        ),
        ortho: preset(_config, "ortho", viewerDefaultOptions.ortho),
        ticks: preset(_config, "ticks", viewerDefaultOptions.ticks),
        centerGrid: preset(
          _config,
          "center_grid",
          viewerDefaultOptions.centerGrid
        ),
        gridFontSize: preset(
          _config,
          "grid_font_size",
          viewerDefaultOptions.gridFontSize
        ),
        timeit: preset(
          _config,
          "timeit",
          viewerDefaultOptions.timeit
        ),
        tools: preset(_config, "tools", viewerDefaultOptions.tools),
        glass: preset(_config, "glass", viewerDefaultOptions.glass),
        up: preset(_config, "up", viewerDefaultOptions.up),
        transparent: preset(
          _config,
          "transparent",
          viewerDefaultOptions.transparent
        ),
        control: preset(
          _config,
          "control",
          viewerDefaultOptions.control
        ),
        panSpeed: preset(
          _config,
          "pan_speed",
          viewerDefaultOptions.panSpeed
        ),
        zoomSpeed: preset(
          _config,
          "zoom_speed",
          viewerDefaultOptions.zoomSpeed
        ),
        rotateSpeed: preset(
          _config,
          "rotate_speed",
          viewerDefaultOptions.rotateSpeed
        ),
        clipSlider0: preset(
          _config,
          "clip_slider_0",
          viewerDefaultOptions.clipSlider0
        ),
        clipSlider1: preset(
          _config,
          "clip_slider_1",
          viewerDefaultOptions.clipSlider1
        ),
        clipSlider2: preset(
          _config,
          "clip_slider_2",
          viewerDefaultOptions.clipSlider2
        ),
        clipNormal0: preset(
          _config,
          "clip_normal_0",
          viewerDefaultOptions.clipNormal0
        ),
        clipNormal1: preset(
          _config,
          "clip_normal_1",
          viewerDefaultOptions.clipNormal1
        ),
        clipNormal2: preset(
          _config,
          "clip_normal_2",
          viewerDefaultOptions.clipNormal2
        ),
        clipIntersection: preset(
          _config,
          "clip_intersection",
          viewerDefaultOptions.clipIntersection
        ),
        clipPlaneHelpers: preset(
          _config,
          "clip_planes",
          viewerDefaultOptions.clipPlaneHelpers
        ),
        clipObjectColors: preset(
          _config,
          "clip_object_colors",
          viewerDefaultOptions.clipObjectColors
        )
      };

      // Ensure theme is set
      if (!_config.theme) {
        _config.theme = getDisplayOptions().theme;
      }

      // Get camera reset mode
      let reset_camera = preset(_config, "reset_camera", "reset");

      // Debug logging if enabled
      if (_config.debug) {
        debugLog("renderOptions", renderOptions);
        debugLog("viewerOptions", viewerOptions);
        debugLog("reset_camera", reset_camera);
      }

      // Calculate bounding box and center for camera positioning
      const bbox = _shapes["bb"];
      const center = [
        (bbox.xmax + bbox.xmin) / 2,
        (bbox.ymax + bbox.ymin) / 2,
        (bbox.zmax + bbox.zmin) / 2
      ];
      let bb_radius = Math.max(
        // bbox.boundingSphere().radius,
        Math.sqrt(
          Math.pow(bbox.xmax - bbox.xmin, 2) +
          Math.pow(bbox.ymax - bbox.ymin, 2) +
          Math.pow(bbox.zmax - bbox.zmin, 2)
        ),
        length(center)
      );

      // Auto-adjust camera reset mode for significant bounding box changes (commented out)
      // if ((reset_camera === "keep") && (last_bb_radius != null) && ((bb_radius < last_bb_radius / 2) || (bb_radius > last_bb_radius * 2))) {
      //     reset_camera = "center";
      //     const msg = `Bounding box 2 times smaller/larger than before, changed reset_camera to Camera.CENTER`;
      //     send("info", msg);
      //     if (_config.debug) {
      //         debugLog(msg);
      //     }
      // }
      last_bb_radius = bb_radius;
      // debugLog("bb_radius", bb_radius)
      // Handle camera positioning based on reset mode
      if (reset_camera !== "keep" && reset_camera !== "center") {
        // Full reset - use configuration values or defaults

        // Apply camera settings from config
        if (_config.zoom !== undefined) {
          viewerOptions.zoom = _config.zoom;
        }
        if (_config.position !== undefined) {
          viewerOptions.position = _config.position;
        }
        if (_config.quaternion !== undefined) {
          viewerOptions.quaternion = _config.quaternion;
        }
        if (_config.target !== undefined) {
          viewerOptions.target = _config.target;
        }

        // Apply clipping settings from config
        if (_config.clip_slider_0 != undefined) {
          viewerOptions.clipSlider0 = _config.clip_slider_0;
        }
        if (_config.clip_slider_1 != undefined) {
          viewerOptions.clipSlider1 = _config.clip_slider_1;
        }
        if (_config.clip_slider_2 != undefined) {
          viewerOptions.clipSlider2 = _config.clip_slider_2;
        }
        if (_config.clip_normal_0 != undefined) {
          viewerOptions.clipNormal0 = _config.clip_normal_0;
        }
        if (_config.clip_normal_1 != undefined) {
          viewerOptions.clipNormal1 = _config.clip_normal_1;
        }
        if (_config.clip_normal_2 != undefined) {
          viewerOptions.clipNormal2 = _config.clip_normal_2;
        }
        if (_config.clip_intersection != undefined) {
          viewerOptions.clipIntersection =
            _config.clip_intersection;
        }
        if (_config.clip_planes != undefined) {
          viewerOptions.clipPlaneHelpers = _config.clip_planes;
        }
        if (_config.clip_object_colors != undefined) {
          viewerOptions.clipObjectColors =
            _config.clip_object_colors;
        }
        _camera_distance = null;
      } else {
        // Keep or center mode - preserve existing camera state with adjustments
        if (_config.position) {
          viewerOptions.position = _config.position;
        } else if (_position) {
          if (reset_camera === "keep") {
            // Keep relative position but adjust for new bounding box
            const camera_distance = 2.5 * bb_radius;

            let p = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
              p[i] = _position[i] - _target[i];
            }
            p = normalize(p);
            let offset =
              reset_camera === "keep" ? _target : [0, 0, 0];
            for (let i = 0; i < 3; i++) {
              p[i] = p[i] * camera_distance + offset[i];
            }
          } else if (reset_camera === "center") {
            // Center camera on new bounding box
            let p = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
              p[i] = _position[i] - _target[i] + center[i];
            }
            _target = center;
          }
          // do nothing when reset_camera is a preset view
        }
        viewerOptions.position = p;
        _position = viewerOptions.position;

        // Handle quaternion (rotation)
        if (_config.quaternion) {
          viewerOptions.quaternion = _config.quaternion;
        } else if (_quaternion) {
          viewerOptions.quaternion = _quaternion;
        }

        // Handle camera target
        if (_config.target) {
          viewerOptions.target = _config.target;
        } else if (_target) {
          viewerOptions.target = _target;
        }

        // Handle zoom level
        if (_config.zoom) {
          viewerOptions.zoom = _config.zoom;
        } else if (_zoom) {
          viewerOptions.zoom = _zoom;
        }

        // Handle clipping sliders - use config values or existing state
        if (_config.clip_slider_0 != undefined) {
          viewerOptions.clipSlider0 = _config.clip_slider_0;
        } else {
          viewerOptions.clipSlider0 = _clipping.sliders[0];
        }
        if (_config.clip_slider_1 != undefined) {
          viewerOptions.clipSlider1 = _config.clip_slider_1;
        } else {
          viewerOptions.clipSlider1 = _clipping.sliders[1];
        }
        if (_config.clip_slider_2 != undefined) {
          viewerOptions.clipSlider2 = _config.clip_slider_2;
        } else {
          viewerOptions.clipSlider2 = _clipping.sliders[2];
        }

        // Handle clipping normals - use config values or existing state
        if (_config.clip_normal_0 != undefined) {
          viewerOptions.clipNormal0 = _config.clip_normal_0;
        } else {
          viewerOptions.clipNormal0 = _clipping.normals[0];
        }
        if (_config.clip_normal_1 != undefined) {
          viewerOptions.clipNormal1 = _config.clip_normal_1;
        } else {
          viewerOptions.clipNormal1 = _clipping.normals[1];
        }
        if (_config.clip_normal_2 != undefined) {
          viewerOptions.clipNormal2 = _config.clip_normal_2;
        } else {
          viewerOptions.clipNormal2 = _clipping.normals[2];
        }

        // Handle other clipping settings
        if (_config.clip_intersection != undefined) {
          viewerOptions.clipIntersection =
            _config.clip_intersection;
        } else {
          viewerOptions.clipIntersection = _clipping.intersection;
        }
        if (_config.clip_planes != undefined) {
          viewerOptions.clipPlaneHelpers = _config.clip_planes;
        } else {
          viewerOptions.clipPlaneHelpers = _clipping.planeHelpers;
        }
        if (_config.clip_object_colors != undefined) {
          viewerOptions.clipObjectColors =
            _config.clip_object_colors;
        } else {
          viewerOptions.clipObjectColors = _clipping.objectColors;
        }
      }

      // Debug logging for final viewer options
      if (_config.debug) {
        debugLog("viewerOptions (modified)", viewerOptions);
      }

      // Render the shapes with the configured options
      debugLog("Rendering objects with three-cad-viewer");
      viewer.render(_shapes, renderOptions, viewerOptions);
      debugLog("Rendering done");

      // Resize CAD view if tree width is specified
      if (_config.tree_width) {
        viewer.resizeCadView(
          viewer.cadWidth,
          viewer.treeWidth,
          viewer.height,
          viewer.glass
        );
      }

      // Adjust zoom for keep mode if camera distance changed
      if (reset_camera === "keep" && _camera_distance != null) {
        // debugLog("camera_distance", _camera_distance, viewer.camera.camera_distance, viewer.camera.camera_distance/_camera_distance);
        viewer.setCameraZoom(
          ((_zoom == null ? 1.0 : _zoom) *
            viewer.camera.camera_distance) /
          _camera_distance
        );
      }

      // Apply preset view if specified
      if (
        [
          "iso",
          "left",
          "right",
          "top",
          "bottom",
          "rear",
          "front"
        ].includes(reset_camera)
      ) {
        viewer.display.setView(reset_camera);
      }

      // Update global state variables with current viewer state
      _position = message["position"] = viewer.getCameraPosition();
      _quaternion = message["quaternion"] =
        viewer.getCameraQuaternion();
      _target = message["target"] = viewer.controls
        .getTarget()
        .toArray();
      _zoom = message["zoom"] = viewer.getCameraZoom();
      _camera_distance = viewer.camera.camera_distance;

      // Update clipping state from viewer
      _clipping = {
        sliders: [
          viewer.getClipSlider(0),
          viewer.getClipSlider(1),
          viewer.getClipSlider(2)
        ],
        normals: [
          viewer.getClipNormal(0),
          viewer.getClipNormal(1),
          viewer.getClipNormal(2)
        ],
        planeHelpers: viewer.getClipPlaneHelpers(),
        objectColors: viewer.getObjectColorCaps(),
        intersection: viewer.getClipIntersection()
      };
      send("status", message);

      // Apply explode mode if enabled
      if (_config.explode) {
        viewer.display.setExplode("", true);
        viewer.display.setExplodeCheck(true);
      }

      // Debug logging for viewer object
      if (_config.debug) {
        console.log("viewer", viewer);
      }
    }

    /**
     * Window resize event handler
     * Adjusts viewer dimensions and updates grid when window is resized
     */
    window.addEventListener(
      "resize",
      function (event) {
        if (viewer != null) {
          const displayOptions = getDisplayOptions(_config.theme);
          viewer.resizeCadView(
            displayOptions.cadWidth,
            displayOptions.treeWidth,
            displayOptions.height,
            displayOptions.glass
          );
          viewer.gridHelper.clearCache();
          viewer.gridHelper.update(viewer.getCameraZoom(), true);
          viewer.update(true, true);
        }
      },
      true
    );

    debugLog("resize listener registered");

    /**
     * Message event handler for communication with VSCode extension
     * Processes different message types: data, screenshot, backend_response, clear, show, ui, animation
     */
    window.addEventListener("message", (event) => {
      /**
       * Extract states from mesh data hierarchy
       * @param {Object} meshData - Mesh data object with parts hierarchy
       * @returns {Object} States object mapping mesh IDs to states
       */
      function getStates(meshData) {
        const states = {};
        function walk(meshData) {
          if (meshData.parts != null) {
            for (let i in meshData.parts) {
              walk(meshData.parts[i]);
            }
          } else {
            states[meshData.id] = meshData.state;
          }
        }
        walk(meshData);
        return states;
      }

      // Parse message data (handle both string and object formats)
      let data =
        typeof event.data === "string" ||
          event.data instanceof String
          ? JSON.parse(event.data)
          : event.data;

      // Handle different message types
      if (
        data.type === "data" &&
        data?.data?.shapes?.parts?.length > 0
      ) {
        // Process 3D shape data with performance timing
        const timer = new Timer("webView", data.config.timeit);

        decode(data);
        timer.split("data decoded");

        // Get previous states for comparison
        let old_states =
          viewer == null
            ? {}
            : viewer.treeview == null
              ? {}
              : viewer.treeview.getStates();

        let meshData = data.data;
        let config = data.config;

        // Handle splash screen zoom adjustment
        if (config._splash) {
          const displayOptions = getDisplayOptions(config.theme);
          config.zoom = Math.min(
            1.0,
            displayOptions.cadWidth / displayOptions.height
          );
          // debugLog("logo zoom =", config.zoom);
        }

        // Show viewer with new data
        showViewer(meshData.shapes, config);
        let new_states = getStates(meshData.shapes);

        const new_keys = Object.keys(new_states);

        // Restore previous states for matching objects
        Object.keys(old_states).forEach((key) => {
          if (new_keys.includes(key)) {
            if (
              new_states[key][0] !== old_states[key][0] ||
              new_states[key][1] !== old_states[key][1]
            ) {
              if (data.config.measure_tools) {
                viewer.treeview.handleStateChange(
                  "node",
                  key,
                  0,
                  old_states[key][0]
                );
                viewer.treeview.handleStateChange(
                  "node",
                  key,
                  1,
                  old_states[key][1]
                );
              } else {
                viewer.setState(key, old_states[key]);
              }
            }
          }
        });
        timer.split("states updated");

        timer.stop();
      } else if (data.type === "screenshot") {
        // Handle screenshot request
        let promise = viewer.getImage(data.filename);
        promise.then((result) => {
          send("screenshot", {
            filename: result.task,
            data: result.dataUrl
          });
        });
      } else if (data.type === "backend_response") {
        // Handle backend response
        viewer.handleBackendResponse(data);
      } else if (data.type === "clear") {
        // Clear viewer
        viewer.clear();
      } else if (data.type === "show") {
        // Show viewer
        showViewer();
      } else if (data.type === "ui") {
        // Skip UI updates during splash screen
        if (_config["_splash"]) {
          return;
        }
        if (data.config.debug) {
          debugLog("data.config", data.config);
        }

        // Process each UI configuration key
        Object.keys(data.config).forEach((key) => {
          if (key === "axes") {
            viewer.setAxes(data.config[key]);
          } else if (key === "axes0") {
            viewer.setAxes0(data.config[key]);
          } else if (key === "grid") {
            viewer.setGrids(data.config[key]);
          } else if (key === "center_grid") {
            viewer.setGridCenter(data.config[key]);
          } else if (key === "ortho") {
            viewer.setOrtho(data.config[key]);
          } else if (key === "transparent") {
            viewer.setTransparent(data.config[key]);
          } else if (key === "black_edges") {
            viewer.setBlackEdges(data.config[key]);
          } else if (key === "zoom") {
            viewer.setCameraZoom(data.config[key]);
          } else if (key === "position") {
            viewer.setCameraPosition(data.config[key]);
          } else if (key === "quaternion") {
            viewer.setCameraQuaternion(data.config[key]);
          } else if (key === "up") {
            viewer.camera.up = data.config[key];
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
            viewer.camera.updateProjectionMatrix();
          } else if (key === "target") {
            viewer.setCameraTarget(data.config[key]);
          } else if (key === "default_edgecolor") {
            viewer.setEdgeColor(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "default_opacity") {
            viewer.setOpacity(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "ambient_intensity") {
            viewer.display.setAmbientLight(data.config[key]);
          } else if (key === "direct_intensity") {
            viewer.display.setDirectLight(data.config[key]);
          } else if (key === "metalness") {
            viewer.display.setMetalness(data.config[key]);
          } else if (key === "roughness") {
            viewer.display.setRoughness(data.config[key]);
          } else if (key === "zoom_speed") {
            viewer.setZoomSpeed(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "pan_speed") {
            viewer.setPanSpeed(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "rotate_speed") {
            viewer.setRotateSpeed(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "glass") {
            viewer.display.glassMode(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "tools") {
            viewer.display.showTools(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "collapse") {
            viewer.display.collapseNodes(data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
          } else if (key === "tree_width") {
            const displayOptions = getDisplayOptions(
              data.config.theme
            );
            const glass =
              data.config.glass !== undefined
                ? data.config.glass
                : displayOptions.glass;
            viewer.resizeCadView(
              displayOptions.cadWidth,
              data.config[key],
              displayOptions.height,
              glass
            );
          } else if (key === "reset_camera") {
            if (data.config[key] === "reset") {
              viewer.display.reset();
            } else if (
              [
                "iso",
                "left",
                "right",
                "top",
                "bottom",
                "rear",
                "front"
              ].includes(data.config[key])
            ) {
              viewer.display.setView(data.config[key]);
            }
          } else if (key === "explode") {
            viewer.display.setExplode("", data.config[key]);
            let change = {};
            change[key] = { new: data.config[key] };
            nc(change);
            viewer.display.setExplodeCheck(data.config[key]);
          } else if (key === "states") {
            const states = Object.keys(
              viewer.treeview.getStates()
            );
            Object.keys(data.config[key]).forEach((key2) => {
              if (states.includes(key2)) {
                viewer.setState(
                  key2,
                  data.config[key][key2]
                );
              }
            });
          } else if (key === "tab") {
            viewer.display.selectTabByName(data.config[key]);
          } else if (key === "clip_intersection") {
            viewer.setClipIntersection(data.config[key]);
          } else if (key.startsWith("clip_slider")) {
            const index = parseInt(key.slice(-1));
            viewer.setClipSlider(index, data.config[key]);
          } else if (key.startsWith("clip_normal")) {
            const index = parseInt(key.slice(-1));
            viewer.setClipNormal(
              index,
              data.config[key],
              viewer.getClipSlider(index)
            );
          } else if (key === "clip_planes") {
            viewer.setClipPlaneHelpers(data.config[key]);
          } else if (key === "clip_object_colors") {
            viewer.setClipObjectColorCaps(data.config[key]);
          }
        });
      } else if (data.type === "animation") {
        // Handle animation data
        // turn off explode
        viewer.display.setExplode({ target: { checked: false } });
        viewer.display.setExplodeCheck(false);
        const tracks = data.data;
        for (let track of tracks) {
          viewer.addAnimationTrack(...track);
        }
        const duration = Math.max(
          ...tracks.map((track) => Math.max(...track[2]))
        );
        if (data.config.speed > 0) {
          viewer.initAnimation(duration, data.config.speed);
        }
      }
    });
    debugLog("message listener registered");

    /**
     * Mutation observer to handle theme changes in VSCode webview
     * Watches for changes to document body class and updates viewer theme accordingly
     */
    const observer = new MutationObserver(() => {
      // handle theme change inside webview
      if (displayDefaultOptions.theme === "browser") {
        viewer.display.setTheme(
          document.body.className === "vscode-light"
            ? "light"
            : "dark"
        );
      } else {
        viewer.display.setTheme(displayDefaultOptions.theme);
      }
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ["class"]
    });

    /**
     * Window load event handler
     * Sends "started" message to VSCode extension after a short delay
     */
    window.addEventListener("load", function () {
      setTimeout(() => {
        send("started", {});
      }, 200);
    });
  </script>
</head>

<body style="padding: 0px; width: fit-content" {{ standalone_init|safe }}>
  <div id="cad_viewer"></div>
</body>

</html>